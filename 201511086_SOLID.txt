#201511086 김민지 - SOLID 원칙

1. SOLID 원칙이란?
  SOLID원칙은 5가지 원칙의 앞글자를 따서 SOLID원칙이라고 하며, 프로그래머가 시간이 지나도 유지 보수와 확장이 쉬운 소프트웨어를 만드는데에 이 원칙들을 적용할 수 있다.

  첫 번째, S는 SRP(Single Responsibility Principle), 단일책임 원칙이다. 이는 소프트웨어의 설계 부품, 즉 클래스, 함수 등은 단 하나의 책임만을 가져야한다는 의미이다. 여기서 책임이라는 단어는 '기능'의 의미로 해석할 수 있다. 예를 들어 만약 한 클래스가 수행하는 기능이 많아진다면, 클래스 내부의 함수끼리 강한 결합을 가질 가능성이 높아지고, 이로 인해 유지보수에 드는 비용이 증가하기 때문에 책임을 분리하여야 한다.

  두 번째, O는 OCP(Open-Closed Principle), 개방-폐쇄 원칙이다. 이는 기존의 코드를 변경하지 않고도 기능을 추가할 수 있도록 설계해야한다는 원칙이다. 즉, 부모 클래스로부터 상속받은 메소드 등을 오버라이딩을 통해 수정하지 않고 확장할 수 있어야 한다는 것이다. OCP를 만족하는 설계를 하기 위해서는 '변경되는 것이 무엇인가?'에 초점을 맞춰야 한다. 즉, 자주 변경되는 내용은 수정하기 쉽도록 설계하고, 변경되지 않아야 하는 것은 수정되는 내용에도 영향을 받지 않도록 하는 것이 중요하다.

  세 번째, L은 LSP(Liskov Substitution Principle), 리스코프 치환 원칙이다. 이는 프로그램에서 부모 클래서의 인스턴스 대신 자식 클래스의 인스턴스로 대체해도 프로그램의 의미가 변화되지 않아야 한다는 것을 의미한다. 이를 위하여 부모 클래스와 자식 클래스는 행위가 일관적이어야 한다.

  네 번째, I는 ISP(Interface Segregation Principle), 인터페이스 분리 원칙이다. 이는 인터페이스를 클라이언트에 특화되지 않도록 분리시켜야 한다는 설계 원칙이다. 즉 클라이언트가 자신이 이용하지 않는 메소드에 의존하지 않아야 한다는 원칙이다. 이 원칙은 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 매소드만 이용할 수 있도록 하는 것이다.

  다섯 번째, D는 DIP(Dependency Inversion Principle), 의존 역전 원칙이다. 이는 의존 관계를 맺을 때, 변화하기 쉬운 것이나 자주 변화하는 것보다는 변화하기 어려운 것, 변화가 거의 없는 것에 의존해야 한다는 원칙이다. 여기에서 변화하기 쉬은 것이란 구체적인 것, 예를 들어 구체화된 클래스,를 말하고, 변화하기 어려운 것은 추상클래스나 인터페이스 등을 의미한다. 따라서 DIP를 만족하기 위해서는 구체적인 클래스와 의존하기보다는 인터페이스나 추상클래스와 의존하는 것이 좋다고 할 수 있다.

2. Duck에 적용된 SOLID 원칙
  첫 번째, 단일책임 원칙의 적용은 Duck 클래스가 너무 많은 책임을 가지기 때문에 이 책임을 분산하기 위하여 Quack, FlyRocketPowered, FlyWithWings의 새로운 클래스를 생성한 것을 통해 알 수 있다.

  두 번째, Duck에 적용된 개방-폐쇄 원칙은 fly, quack을 변동할 수 있는 인터페이스로 구현한 것이다. fly와 quack은 하위 클래스에 따라서 다르게 구현되어야 하는데, 만약 이것을 구체적인 클래스로 구현했다면, fly와 quack은 하위 클래스에서 메소드를 상속받아 오버라이딩을 통해 수정하는 과정을 거쳐야 한다.

  세 번째, Duck에 적용된 리스코프 치환 원칙은 'MiniDuckSimulator1' 클래스에서
		'Duck mallard = new MallardDuck();'
와 같은 코드를 통해 볼 수 있다. 이 코드는 Duck의 자식 클래스인 MallardDuck에서 인스턴스를 생성하고, 그것으로 부모 클래스인 Duck의 인스턴스를 대체하는 것을 보여준다.

  네 번째, Duck에 적용된 인터페이스 분리 원칙은 QuackBehavior, FlyBehavior을 각각의 인터페이스로 나눈 것을 통하여 적용되었다고 볼 수 있다. Duck의 자식 클래스 중 quack()이나 fly()의 기능을 사용하지 않는 자식 클래스가 있을 수 있다. 만약 quack()과 fly()가 인터페이스로 분리되지 않았다면 사용하지 않는 함수임에도 불구하고 이와도 의존해야 했겠지만, 인터페이스로 분리되어서 필요할 때에만 의존할 수 있다는 것이다.

  다섯 번째, Duck에 적용된 의존 역전 원칙은 인터페이스인 QuackBehavior, FlyBehavior과의 의존 관계를 맺을 때, 변화하기 쉬운 자식 클래스가 아닌 변화하기 어려운 부모 클래스인 Duck과 의존 관계를 맺은 부분이 의존 역전 원칙이 적용되었다고 할 수 있다.